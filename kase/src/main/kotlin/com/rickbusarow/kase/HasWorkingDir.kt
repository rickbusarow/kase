/*
 * Copyright (C) 2023 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.rickbusarow.kase

import com.rickbusarow.kase.stdlib.div
import org.junit.jupiter.api.TestFactory
import java.io.File

/**
 * @param workingDir the directory containing all source and generated files to be used in this test
 */
@Suppress("UnnecessaryAbstractClass")
public abstract class HasWorkingDir(workingDir: File) {

  /** the directory containing all source and generated files to be used in this test */
  public val workingDir: File by lazy {
    checkInWorkingDir(workingDir)
    workingDir.deleteRecursively()
    workingDir
  }

  /** relative to [workingDir] */
  public fun File.relativePath(): String = relativeTo(workingDir).path

  override fun toString(): String {
    return "workingDir=$workingDir\n" + getSourceReport()
  }

  private fun getSourceReport(): String {

    val grouped = workingDir
      .walkBottomUp()
      .filter { it.isFile }
      .groupBy { generated ->
        val pathSegments = generated.relativeTo(workingDir).path.split(File.separator)

        if (pathSegments.size > 1) {
          pathSegments.first()
        } else {
          "<root>"
        }
      }
      .toList()
      .sortedBy { it.first }

    return buildString {
      appendLine("====")
      grouped.forEach { (type, files) ->
        appendLine("## $type")
        files.forEach { path ->
          appendLine("file://$path")
        }
      }
      appendLine("----")
    }
  }

  public companion object {

    private val allWorkingDirs = mutableSetOf<File>()

    @PublishedApi
    internal fun checkInWorkingDir(workingDir: File) {
      synchronized(allWorkingDirs) {
        require(allWorkingDirs.add(workingDir)) {
          val annotation = "${TestFactory::class.simpleName}"
          """
          A working directory with this path has already been registered during this test run,
          meaning it would have multiple tests modifying it concurrently.

          This probably means you need to add test variant names to your TestEnvironment instance.

            @$annotation
            fun myTestFactory(
              @Language("proto")
              vararg content: String,
              /* ... /*
            ) = ...

          This is the working directory which would be duplicated: $workingDir
          """.trimIndent()
        }
      }
    }

    /**
     * Determines an appropriate working directory based upon the current class under
     * test, the languages being generated by Wire, and the current test function.
     *
     * @param testVariantNames additional subdirectories underneath the test
     *   function's name, such as the names of the languages being generated
     * @param testFunctionCoordinates details about the actual test function, so that
     *   we can get the test name. This must be grabbed as soon as possible, since
     *   default functions, inline functions, sequences, and iterators all redirect
     *   things and have a chance of hiding the original calling function completely.
     * @return a File directory corresponding to the root of the working directory for this test
     */
    public fun createWorkingDir(
      testVariantNames: List<String>,
      testFunctionCoordinates: TestFunctionCoordinates = TestFunctionCoordinates.get()
    ): File {

      val testFunctionDirectoryName = testFunctionCoordinates.callingFunctionSimpleName
        .cleanForFileSystem()

      val testClassDirectoryName = testFunctionCoordinates.declaringClassSimpleNames
        // "MyTest/nested class"
        .joinToString(File.separator)
        // "MyTest/nested_class"
        .replace("[^a-zA-Z\\d/]".toRegex(), "_")

      val baseWorkingDir = System.getProperty("kase.baseWorkingDir", "build" / "kase")
        .let { File(it).absoluteFile }

      val working =
        baseWorkingDir / testClassDirectoryName / testFunctionDirectoryName / testVariantNames
          .joinToString(File.separator) { it.cleanForFileSystem() }

      return working.absoluteFile
    }

    @PublishedApi
    internal infix operator fun String.div(other: String): String =
      "$this${File.separatorChar}$other"

    @PublishedApi
    internal fun String.cleanForFileSystem(): String = replace("[^a-zA-Z\\d]+".toRegex(), "_")
      .removeSuffix("_")
  }
}
