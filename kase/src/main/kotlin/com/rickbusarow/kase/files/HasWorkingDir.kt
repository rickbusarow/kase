/*
 * Copyright (C) 2023 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.rickbusarow.kase.files

import com.rickbusarow.kase.stdlib.cleanOutput
import com.rickbusarow.kase.stdlib.div
import com.rickbusarow.kase.stdlib.useRelativePaths
import java.io.File

/** relative to [workingDir][HasWorkingDir.workingDir] */
context(HasWorkingDir)
public fun File.relativePath(): String = relativeTo(workingDir).path

/** replace absolute paths with relative ones */
context(HasWorkingDir)
public fun String.useRelativePaths(): String = useRelativePaths(workingDir)

/**
 * Removes various bits of noise and machine-specific variables from a console or report output.
 * Cleans the provided string by applying various modifications such as normalising line separators,
 * using relative paths, enforcing Unix file separators, and removing specific strings or patterns.
 *
 * @receiver The raw string that needs to be cleaned.
 * @return The cleaned string.
 * @see com.rickbusarow.kase.stdlib.cleanOutput
 */
context(HasWorkingDir)
public fun String.cleanOutput(): String = cleanOutput(workingDir)

/** Represents a test that has a working directory. */
public interface HasWorkingDir {
  /** the directory containing all source and generated files to be used in this test */
  public val workingDir: File

  public companion object {

    /** Creates a [HasWorkingDir] instance with a working directory. */
    public operator fun invoke(workingDir: File): DefaultHasWorkingDir {
      return DefaultHasWorkingDir(workingDir)
    }

    /**
     * Creates a [HasWorkingDir] instance with a working
     * directory based on the current test function.
     */
    public operator fun invoke(
      testVariantNames: List<String>,
      testFunctionCoordinates: TestFunctionCoordinates = TestFunctionCoordinates.get()
    ): DefaultHasWorkingDir = DefaultHasWorkingDir(
      createWorkingDirFile(
        testVariantNames = testVariantNames,
        testFunctionCoordinates = testFunctionCoordinates
      )
    )

    /**
     * Determines an appropriate working directory based upon the current class under
     * test, the languages being generated by Wire, and the current test function.
     *
     * @param testVariantNames additional subdirectories underneath the test
     *   function's name, such as the names of the languages being generated
     * @param testFunctionCoordinates details about the actual test function, so that
     *   we can get the test name. This must be grabbed as soon as possible, since
     *   default functions, inline functions, sequences, and iterators all redirect
     *   things and have a chance of hiding the original calling function completely.
     * @return a File directory corresponding to the root of the working directory for this test
     */
    public fun createWorkingDirFile(
      testVariantNames: List<String>,
      testFunctionCoordinates: TestFunctionCoordinates = TestFunctionCoordinates.get()
    ): File {

      val testFunctionDirectoryName =
        cleanStringForFileSystem(testFunctionCoordinates.callingFunctionSimpleName)

      val testClassDirectoryName = testFunctionCoordinates.declaringClassSimpleNames
        // "MyTest/nested class"
        .joinToString(File.separator)
        // "MyTest/nested_class"
        .replace("[^a-zA-Z\\d/]".toRegex(), "_")

      val baseWorkingDir = System.getProperty("kase.baseWorkingDir", "build" / "kase")
        .let { File(it).absoluteFile }

      val working =
        baseWorkingDir / testClassDirectoryName / testFunctionDirectoryName / testVariantNames
          .joinToString(File.separator) { cleanStringForFileSystem(it) }

      return working.absoluteFile
    }

    @PublishedApi
    internal infix operator fun String.div(other: String): String {
      return "$this${File.separatorChar}$other"
    }

    @PublishedApi
    internal fun cleanStringForFileSystem(string: String): String {
      return string.replace("[^a-zA-Z\\d]+".toRegex(), "_")
        .removeSuffix("_")
    }
  }
}
